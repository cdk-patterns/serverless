import { Test } from 'nodeunit';
declare const _default: {
    'creating a String SSM Parameter'(test: Test): void;
    'String SSM Parameter rejects invalid values'(test: Test): void;
    'String SSM Parameter allows unresolved tokens'(test: Test): void;
    'creating a StringList SSM Parameter'(test: Test): void;
    'StringList SSM Parameter values cannot contain commas'(test: Test): void;
    'StringList SSM Parameter rejects invalid values'(test: Test): void;
    'StringList SSM Parameter allows unresolved tokens'(test: Test): void;
    'parameterArn is crafted correctly'(test: Test): void;
    'parameterName that includes a "/" must be fully qualified (i.e. begin with "/") as well'(test: Test): void;
    'StringParameter.fromStringParameterName'(test: Test): void;
    'StringParameter.fromStringParameterAttributes'(test: Test): void;
    'StringParameter.fromSecureStringParameterAttributes'(test: Test): void;
    'StringParameter.fromSecureStringParameterAttributes with encryption key creates the correct policy for grantRead'(test: Test): void;
    'StringParameter.fromSecureStringParameterAttributes with encryption key creates the correct policy for grantWrite'(test: Test): void;
    'StringListParameter.fromName'(test: Test): void;
    'fromLookup will use the SSM context provider to read value during synthesis'(test: Test): void;
    'valueForStringParameter': {
        'returns a token that represents the SSM parameter value'(test: Test): void;
        'de-dup based on parameter name'(test: Test): void;
        'can query actual SSM Parameter Names, multiple times'(test: Test): void;
    };
    'rendering of parameter arns'(test: Test): void;
    'if parameterName is a token separator must be specified'(test: Test): void;
    'fails if name is a token and no explicit separator'(test: Test): void;
    'fails if simpleName is wrong based on a concrete physical name'(test: Test): void;
    'fails if parameterName is undefined and simpleName is "false"'(test: Test): void;
};
export = _default;
