"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Provides default values for certain regional information points.
 */
class Default {
    /**
     * Computes a "standard" AWS Service principal for a given service, region and suffix. This is useful for example when
     * you need to compute a service principal name, but you do not have a synthesize-time region literal available (so
     * all you have is `{ "Ref": "AWS::Region" }`). This way you get the same defaulting behavior that is normally used
     * for built-in data.
     *
     * @param service   the name of the service (s3, s3.amazonaws.com, ...)
     * @param region    the region in which the service principal is needed.
     * @param urlSuffix the URL suffix for the partition in which the region is located.
     */
    static servicePrincipal(service, region, urlSuffix) {
        const matches = service.match(/^([^.]+)(?:\.amazonaws\.com(?:\.cn)?)?$/);
        if (!matches) {
            // Return "service" if it does not look like any of the following:
            // - s3
            // - s3.amazonaws.com
            // - s3.amazonaws.com.cn
            return service;
        }
        service = matches[1]; // Simplify the service name down to something like "s3"
        switch (service) {
            // Services with a regional AND partitional principal
            case 'codedeploy':
            case 'logs':
                return `${service}.${region}.${urlSuffix}`;
            // Services with a regional principal
            case 'states':
                return `${service}.${region}.amazonaws.com`;
            // Services with a partitional principal
            case 'ec2':
                return `${service}.${urlSuffix}`;
            // Services with a universal principal across all regions/partitions (the default case)
            default:
                return `${service}.amazonaws.com`;
        }
    }
    constructor() { }
}
exports.Default = Default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlZmF1bHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7R0FFRztBQUNILE1BQWEsT0FBTztJQUNsQjs7Ozs7Ozs7O09BU0c7SUFDSSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsT0FBZSxFQUFFLE1BQWMsRUFBRSxTQUFpQjtRQUMvRSxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7UUFDekUsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNaLGtFQUFrRTtZQUNsRSxPQUFPO1lBQ1AscUJBQXFCO1lBQ3JCLHdCQUF3QjtZQUN4QixPQUFPLE9BQU8sQ0FBQztTQUNoQjtRQUVELE9BQU8sR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyx3REFBd0Q7UUFDOUUsUUFBUSxPQUFPLEVBQUU7WUFDZixxREFBcUQ7WUFDckQsS0FBSyxZQUFZLENBQUM7WUFDbEIsS0FBSyxNQUFNO2dCQUNULE9BQU8sR0FBRyxPQUFPLElBQUksTUFBTSxJQUFJLFNBQVMsRUFBRSxDQUFDO1lBRTdDLHFDQUFxQztZQUNyQyxLQUFLLFFBQVE7Z0JBQ1gsT0FBTyxHQUFHLE9BQU8sSUFBSSxNQUFNLGdCQUFnQixDQUFDO1lBRTlDLHdDQUF3QztZQUN4QyxLQUFLLEtBQUs7Z0JBQ1IsT0FBTyxHQUFHLE9BQU8sSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUVuQyx1RkFBdUY7WUFDdkY7Z0JBQ0ksT0FBTyxHQUFHLE9BQU8sZ0JBQWdCLENBQUM7U0FFdkM7SUFDSCxDQUFDO0lBRUQsZ0JBQXdCLENBQUM7Q0FDMUI7QUE1Q0QsMEJBNENDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm92aWRlcyBkZWZhdWx0IHZhbHVlcyBmb3IgY2VydGFpbiByZWdpb25hbCBpbmZvcm1hdGlvbiBwb2ludHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0IHtcbiAgLyoqXG4gICAqIENvbXB1dGVzIGEgXCJzdGFuZGFyZFwiIEFXUyBTZXJ2aWNlIHByaW5jaXBhbCBmb3IgYSBnaXZlbiBzZXJ2aWNlLCByZWdpb24gYW5kIHN1ZmZpeC4gVGhpcyBpcyB1c2VmdWwgZm9yIGV4YW1wbGUgd2hlblxuICAgKiB5b3UgbmVlZCB0byBjb21wdXRlIGEgc2VydmljZSBwcmluY2lwYWwgbmFtZSwgYnV0IHlvdSBkbyBub3QgaGF2ZSBhIHN5bnRoZXNpemUtdGltZSByZWdpb24gbGl0ZXJhbCBhdmFpbGFibGUgKHNvXG4gICAqIGFsbCB5b3UgaGF2ZSBpcyBgeyBcIlJlZlwiOiBcIkFXUzo6UmVnaW9uXCIgfWApLiBUaGlzIHdheSB5b3UgZ2V0IHRoZSBzYW1lIGRlZmF1bHRpbmcgYmVoYXZpb3IgdGhhdCBpcyBub3JtYWxseSB1c2VkXG4gICAqIGZvciBidWlsdC1pbiBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gc2VydmljZSAgIHRoZSBuYW1lIG9mIHRoZSBzZXJ2aWNlIChzMywgczMuYW1hem9uYXdzLmNvbSwgLi4uKVxuICAgKiBAcGFyYW0gcmVnaW9uICAgIHRoZSByZWdpb24gaW4gd2hpY2ggdGhlIHNlcnZpY2UgcHJpbmNpcGFsIGlzIG5lZWRlZC5cbiAgICogQHBhcmFtIHVybFN1ZmZpeCB0aGUgVVJMIHN1ZmZpeCBmb3IgdGhlIHBhcnRpdGlvbiBpbiB3aGljaCB0aGUgcmVnaW9uIGlzIGxvY2F0ZWQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNlcnZpY2VQcmluY2lwYWwoc2VydmljZTogc3RyaW5nLCByZWdpb246IHN0cmluZywgdXJsU3VmZml4OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzZXJ2aWNlLm1hdGNoKC9eKFteLl0rKSg/OlxcLmFtYXpvbmF3c1xcLmNvbSg/OlxcLmNuKT8pPyQvKTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIC8vIFJldHVybiBcInNlcnZpY2VcIiBpZiBpdCBkb2VzIG5vdCBsb29rIGxpa2UgYW55IG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgICAvLyAtIHMzXG4gICAgICAvLyAtIHMzLmFtYXpvbmF3cy5jb21cbiAgICAgIC8vIC0gczMuYW1hem9uYXdzLmNvbS5jblxuICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgfVxuXG4gICAgc2VydmljZSA9IG1hdGNoZXNbMV07IC8vIFNpbXBsaWZ5IHRoZSBzZXJ2aWNlIG5hbWUgZG93biB0byBzb21ldGhpbmcgbGlrZSBcInMzXCJcbiAgICBzd2l0Y2ggKHNlcnZpY2UpIHtcbiAgICAgIC8vIFNlcnZpY2VzIHdpdGggYSByZWdpb25hbCBBTkQgcGFydGl0aW9uYWwgcHJpbmNpcGFsXG4gICAgICBjYXNlICdjb2RlZGVwbG95JzpcbiAgICAgIGNhc2UgJ2xvZ3MnOlxuICAgICAgICByZXR1cm4gYCR7c2VydmljZX0uJHtyZWdpb259LiR7dXJsU3VmZml4fWA7XG5cbiAgICAgIC8vIFNlcnZpY2VzIHdpdGggYSByZWdpb25hbCBwcmluY2lwYWxcbiAgICAgIGNhc2UgJ3N0YXRlcyc6XG4gICAgICAgIHJldHVybiBgJHtzZXJ2aWNlfS4ke3JlZ2lvbn0uYW1hem9uYXdzLmNvbWA7XG5cbiAgICAgIC8vIFNlcnZpY2VzIHdpdGggYSBwYXJ0aXRpb25hbCBwcmluY2lwYWxcbiAgICAgIGNhc2UgJ2VjMic6XG4gICAgICAgIHJldHVybiBgJHtzZXJ2aWNlfS4ke3VybFN1ZmZpeH1gO1xuXG4gICAgICAvLyBTZXJ2aWNlcyB3aXRoIGEgdW5pdmVyc2FsIHByaW5jaXBhbCBhY3Jvc3MgYWxsIHJlZ2lvbnMvcGFydGl0aW9ucyAodGhlIGRlZmF1bHQgY2FzZSlcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGAke3NlcnZpY2V9LmFtYXpvbmF3cy5jb21gO1xuXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHsgfVxufVxuIl19