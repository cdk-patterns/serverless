"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const semver = require("semver");
// ----------------------------------------------------------------------
//
//   READ THIS FIRST WHEN CHANGING THIS FILE
//
// ----------------------------------------------------------------------
//
// You need (and only need) to bump the CLOUD_ASSEMBLY_VERSION if the cloud
// assembly needs new features from the CDK CLI. Examples: new fields, new
// behavior, new artifact types.
//
// If that happens, you set the CLOUD_ASSEMBLY_VERSION to the *next* (not the
// current!) CDK version that will be released. This is done to produce
// useful error messages.
//
// When you do this, you will force users of a new library to upgrade the CLI
// (good), but UNLESS YOU ALSO IMPLEMENT 'upgradeAssemblyManifest' you will also
// force people who have installed a newer CLI to upgrade their libraries (bad!).
// Do that too, unless you have a very good reason not to.
/**
 * Bump this to the library version if and only if the CX protocol changes.
 *
 * We could also have used 1, 2, 3, ... here to indicate protocol versions, but
 * those then still need to be mapped to software versions to be useful. So we
 * might as well use the software version as protocol version and immediately
 * generate a useful error message from this.
 *
 * Note that the versions are not compared in a semver way, they are used as
 * opaque ordered tokens.
 */
exports.CLOUD_ASSEMBLY_VERSION = '1.21.0';
/**
 * Look at the type of response we get and upgrade it to the latest expected version
 */
function verifyManifestVersion(manifetVersion) {
    const frameworkVersion = parseSemver(manifetVersion);
    const toolkitVersion = parseSemver(exports.CLOUD_ASSEMBLY_VERSION);
    // if framework > cli, we require a newer cli version
    if (semver.gt(frameworkVersion, toolkitVersion)) {
        throw new Error(`A newer version of the CDK CLI (>= ${frameworkVersion}) is necessary to interact with this app`);
    }
    // if framework < cli, we require a newer framework version
    if (semver.lt(frameworkVersion, toolkitVersion)) {
        throw new Error(`The CDK CLI you are using requires your app to use CDK modules with version >= ${exports.CLOUD_ASSEMBLY_VERSION}`);
    }
}
exports.verifyManifestVersion = verifyManifestVersion;
/**
 * Upgrade old manifest versions to later manifest version here (if possible).
 *
 * Use this to make the toolkit recognize old assembly versions. This function should
 * add newly required fields with appropriate default values, etc.
 */
function upgradeAssemblyManifest(manifest) {
    if (manifest.version === '0.36.0') {
        // Adding a new artifact type, old version will not have it so painless upgrade.
        manifest = justUpgradeVersion(manifest, '1.10.0');
    }
    if (manifest.version === '1.10.0') {
        // Two changes:
        // * Backwards-compatible changes to the VPC provider
        // * Added AMI context provider: old assemblies won't reference it.
        manifest = justUpgradeVersion(manifest, '1.16.0');
    }
    if (manifest.version === '1.16.0') {
        // Backwards compatible changes to ContainerImageAssetMetadataEntry:
        // * Make `imageNameParameter` optional (new apps do not require it anymore because container images go to a well-known repository)
        // * Add optional `imageTag` to allow apps to specify exactly where to store the image (required if `imageNameParameter` is not defined)
        manifest = justUpgradeVersion(manifest, '1.21.0');
    }
    return manifest;
}
exports.upgradeAssemblyManifest = upgradeAssemblyManifest;
function parseSemver(version) {
    const ver = semver.coerce(version);
    if (!ver) {
        throw new Error(`Could not parse "${version}" as semver`);
    }
    return ver;
}
/**
 * Return a copy of the manifest with just the version field updated
 *
 * Useful if there are protocol changes that are automatically backwards
 * compatible.
 */
function justUpgradeVersion(manifest, version) {
    return Object.assign({}, manifest, { version });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbmluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZlcnNpb25pbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxpQ0FBaUM7QUFHakMseUVBQXlFO0FBQ3pFLEVBQUU7QUFDRiw0Q0FBNEM7QUFDNUMsRUFBRTtBQUNGLHlFQUF5RTtBQUN6RSxFQUFFO0FBQ0YsMkVBQTJFO0FBQzNFLDBFQUEwRTtBQUMxRSxnQ0FBZ0M7QUFDaEMsRUFBRTtBQUNGLDZFQUE2RTtBQUM3RSx1RUFBdUU7QUFDdkUseUJBQXlCO0FBQ3pCLEVBQUU7QUFDRiw2RUFBNkU7QUFDN0UsZ0ZBQWdGO0FBQ2hGLGlGQUFpRjtBQUNqRiwwREFBMEQ7QUFFMUQ7Ozs7Ozs7Ozs7R0FVRztBQUNVLFFBQUEsc0JBQXNCLEdBQUcsUUFBUSxDQUFDO0FBRS9DOztHQUVHO0FBQ0gsU0FBZ0IscUJBQXFCLENBQUMsY0FBc0I7SUFDMUQsTUFBTSxnQkFBZ0IsR0FBRyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDckQsTUFBTSxjQUFjLEdBQUcsV0FBVyxDQUFDLDhCQUFzQixDQUFDLENBQUM7SUFFM0QscURBQXFEO0lBQ3JELElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLENBQUMsRUFBRTtRQUMvQyxNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxnQkFBZ0IsMENBQTBDLENBQUMsQ0FBQztLQUNuSDtJQUVELDJEQUEyRDtJQUMzRCxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsY0FBYyxDQUFDLEVBQUU7UUFDL0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxrRkFBa0YsOEJBQXNCLEVBQUUsQ0FBQyxDQUFDO0tBQzdIO0FBQ0gsQ0FBQztBQWJELHNEQWFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQix1QkFBdUIsQ0FBQyxRQUEwQjtJQUVoRSxJQUFJLFFBQVEsQ0FBQyxPQUFPLEtBQUssUUFBUSxFQUFFO1FBQ2pDLGdGQUFnRjtRQUNoRixRQUFRLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ25EO0lBRUQsSUFBSSxRQUFRLENBQUMsT0FBTyxLQUFLLFFBQVEsRUFBRTtRQUNqQyxlQUFlO1FBQ2YscURBQXFEO1FBQ3JELG1FQUFtRTtRQUNuRSxRQUFRLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ25EO0lBRUQsSUFBSSxRQUFRLENBQUMsT0FBTyxLQUFLLFFBQVEsRUFBRTtRQUNqQyxvRUFBb0U7UUFDcEUsbUlBQW1JO1FBQ25JLHdJQUF3STtRQUN4SSxRQUFRLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ25EO0lBRUQsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQztBQXRCRCwwREFzQkM7QUFFRCxTQUFTLFdBQVcsQ0FBQyxPQUFlO0lBQ2xDLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbkMsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNSLE1BQU0sSUFBSSxLQUFLLENBQUMsb0JBQW9CLE9BQU8sYUFBYSxDQUFDLENBQUM7S0FDM0Q7SUFFRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQVMsa0JBQWtCLENBQUMsUUFBMEIsRUFBRSxPQUFlO0lBQ3JFLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsUUFBUSxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztBQUNsRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgeyBBc3NlbWJseU1hbmlmZXN0IH0gZnJvbSAnLi9jbG91ZC1hc3NlbWJseSc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vXG4vLyAgIFJFQUQgVEhJUyBGSVJTVCBXSEVOIENIQU5HSU5HIFRISVMgRklMRVxuLy9cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vXG4vLyBZb3UgbmVlZCAoYW5kIG9ubHkgbmVlZCkgdG8gYnVtcCB0aGUgQ0xPVURfQVNTRU1CTFlfVkVSU0lPTiBpZiB0aGUgY2xvdWRcbi8vIGFzc2VtYmx5IG5lZWRzIG5ldyBmZWF0dXJlcyBmcm9tIHRoZSBDREsgQ0xJLiBFeGFtcGxlczogbmV3IGZpZWxkcywgbmV3XG4vLyBiZWhhdmlvciwgbmV3IGFydGlmYWN0IHR5cGVzLlxuLy9cbi8vIElmIHRoYXQgaGFwcGVucywgeW91IHNldCB0aGUgQ0xPVURfQVNTRU1CTFlfVkVSU0lPTiB0byB0aGUgKm5leHQqIChub3QgdGhlXG4vLyBjdXJyZW50ISkgQ0RLIHZlcnNpb24gdGhhdCB3aWxsIGJlIHJlbGVhc2VkLiBUaGlzIGlzIGRvbmUgdG8gcHJvZHVjZVxuLy8gdXNlZnVsIGVycm9yIG1lc3NhZ2VzLlxuLy9cbi8vIFdoZW4geW91IGRvIHRoaXMsIHlvdSB3aWxsIGZvcmNlIHVzZXJzIG9mIGEgbmV3IGxpYnJhcnkgdG8gdXBncmFkZSB0aGUgQ0xJXG4vLyAoZ29vZCksIGJ1dCBVTkxFU1MgWU9VIEFMU08gSU1QTEVNRU5UICd1cGdyYWRlQXNzZW1ibHlNYW5pZmVzdCcgeW91IHdpbGwgYWxzb1xuLy8gZm9yY2UgcGVvcGxlIHdobyBoYXZlIGluc3RhbGxlZCBhIG5ld2VyIENMSSB0byB1cGdyYWRlIHRoZWlyIGxpYnJhcmllcyAoYmFkISkuXG4vLyBEbyB0aGF0IHRvbywgdW5sZXNzIHlvdSBoYXZlIGEgdmVyeSBnb29kIHJlYXNvbiBub3QgdG8uXG5cbi8qKlxuICogQnVtcCB0aGlzIHRvIHRoZSBsaWJyYXJ5IHZlcnNpb24gaWYgYW5kIG9ubHkgaWYgdGhlIENYIHByb3RvY29sIGNoYW5nZXMuXG4gKlxuICogV2UgY291bGQgYWxzbyBoYXZlIHVzZWQgMSwgMiwgMywgLi4uIGhlcmUgdG8gaW5kaWNhdGUgcHJvdG9jb2wgdmVyc2lvbnMsIGJ1dFxuICogdGhvc2UgdGhlbiBzdGlsbCBuZWVkIHRvIGJlIG1hcHBlZCB0byBzb2Z0d2FyZSB2ZXJzaW9ucyB0byBiZSB1c2VmdWwuIFNvIHdlXG4gKiBtaWdodCBhcyB3ZWxsIHVzZSB0aGUgc29mdHdhcmUgdmVyc2lvbiBhcyBwcm90b2NvbCB2ZXJzaW9uIGFuZCBpbW1lZGlhdGVseVxuICogZ2VuZXJhdGUgYSB1c2VmdWwgZXJyb3IgbWVzc2FnZSBmcm9tIHRoaXMuXG4gKlxuICogTm90ZSB0aGF0IHRoZSB2ZXJzaW9ucyBhcmUgbm90IGNvbXBhcmVkIGluIGEgc2VtdmVyIHdheSwgdGhleSBhcmUgdXNlZCBhc1xuICogb3BhcXVlIG9yZGVyZWQgdG9rZW5zLlxuICovXG5leHBvcnQgY29uc3QgQ0xPVURfQVNTRU1CTFlfVkVSU0lPTiA9ICcxLjIxLjAnO1xuXG4vKipcbiAqIExvb2sgYXQgdGhlIHR5cGUgb2YgcmVzcG9uc2Ugd2UgZ2V0IGFuZCB1cGdyYWRlIGl0IHRvIHRoZSBsYXRlc3QgZXhwZWN0ZWQgdmVyc2lvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5TWFuaWZlc3RWZXJzaW9uKG1hbmlmZXRWZXJzaW9uOiBzdHJpbmcpIHtcbiAgY29uc3QgZnJhbWV3b3JrVmVyc2lvbiA9IHBhcnNlU2VtdmVyKG1hbmlmZXRWZXJzaW9uKTtcbiAgY29uc3QgdG9vbGtpdFZlcnNpb24gPSBwYXJzZVNlbXZlcihDTE9VRF9BU1NFTUJMWV9WRVJTSU9OKTtcblxuICAvLyBpZiBmcmFtZXdvcmsgPiBjbGksIHdlIHJlcXVpcmUgYSBuZXdlciBjbGkgdmVyc2lvblxuICBpZiAoc2VtdmVyLmd0KGZyYW1ld29ya1ZlcnNpb24sIHRvb2xraXRWZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBDREsgQ0xJICg+PSAke2ZyYW1ld29ya1ZlcnNpb259KSBpcyBuZWNlc3NhcnkgdG8gaW50ZXJhY3Qgd2l0aCB0aGlzIGFwcGApO1xuICB9XG5cbiAgLy8gaWYgZnJhbWV3b3JrIDwgY2xpLCB3ZSByZXF1aXJlIGEgbmV3ZXIgZnJhbWV3b3JrIHZlcnNpb25cbiAgaWYgKHNlbXZlci5sdChmcmFtZXdvcmtWZXJzaW9uLCB0b29sa2l0VmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBDREsgQ0xJIHlvdSBhcmUgdXNpbmcgcmVxdWlyZXMgeW91ciBhcHAgdG8gdXNlIENESyBtb2R1bGVzIHdpdGggdmVyc2lvbiA+PSAke0NMT1VEX0FTU0VNQkxZX1ZFUlNJT059YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBVcGdyYWRlIG9sZCBtYW5pZmVzdCB2ZXJzaW9ucyB0byBsYXRlciBtYW5pZmVzdCB2ZXJzaW9uIGhlcmUgKGlmIHBvc3NpYmxlKS5cbiAqXG4gKiBVc2UgdGhpcyB0byBtYWtlIHRoZSB0b29sa2l0IHJlY29nbml6ZSBvbGQgYXNzZW1ibHkgdmVyc2lvbnMuIFRoaXMgZnVuY3Rpb24gc2hvdWxkXG4gKiBhZGQgbmV3bHkgcmVxdWlyZWQgZmllbGRzIHdpdGggYXBwcm9wcmlhdGUgZGVmYXVsdCB2YWx1ZXMsIGV0Yy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZ3JhZGVBc3NlbWJseU1hbmlmZXN0KG1hbmlmZXN0OiBBc3NlbWJseU1hbmlmZXN0KTogQXNzZW1ibHlNYW5pZmVzdCB7XG5cbiAgaWYgKG1hbmlmZXN0LnZlcnNpb24gPT09ICcwLjM2LjAnKSB7XG4gICAgLy8gQWRkaW5nIGEgbmV3IGFydGlmYWN0IHR5cGUsIG9sZCB2ZXJzaW9uIHdpbGwgbm90IGhhdmUgaXQgc28gcGFpbmxlc3MgdXBncmFkZS5cbiAgICBtYW5pZmVzdCA9IGp1c3RVcGdyYWRlVmVyc2lvbihtYW5pZmVzdCwgJzEuMTAuMCcpO1xuICB9XG5cbiAgaWYgKG1hbmlmZXN0LnZlcnNpb24gPT09ICcxLjEwLjAnKSB7XG4gICAgLy8gVHdvIGNoYW5nZXM6XG4gICAgLy8gKiBCYWNrd2FyZHMtY29tcGF0aWJsZSBjaGFuZ2VzIHRvIHRoZSBWUEMgcHJvdmlkZXJcbiAgICAvLyAqIEFkZGVkIEFNSSBjb250ZXh0IHByb3ZpZGVyOiBvbGQgYXNzZW1ibGllcyB3b24ndCByZWZlcmVuY2UgaXQuXG4gICAgbWFuaWZlc3QgPSBqdXN0VXBncmFkZVZlcnNpb24obWFuaWZlc3QsICcxLjE2LjAnKTtcbiAgfVxuXG4gIGlmIChtYW5pZmVzdC52ZXJzaW9uID09PSAnMS4xNi4wJykge1xuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmxlIGNoYW5nZXMgdG8gQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnk6XG4gICAgLy8gKiBNYWtlIGBpbWFnZU5hbWVQYXJhbWV0ZXJgIG9wdGlvbmFsIChuZXcgYXBwcyBkbyBub3QgcmVxdWlyZSBpdCBhbnltb3JlIGJlY2F1c2UgY29udGFpbmVyIGltYWdlcyBnbyB0byBhIHdlbGwta25vd24gcmVwb3NpdG9yeSlcbiAgICAvLyAqIEFkZCBvcHRpb25hbCBgaW1hZ2VUYWdgIHRvIGFsbG93IGFwcHMgdG8gc3BlY2lmeSBleGFjdGx5IHdoZXJlIHRvIHN0b3JlIHRoZSBpbWFnZSAocmVxdWlyZWQgaWYgYGltYWdlTmFtZVBhcmFtZXRlcmAgaXMgbm90IGRlZmluZWQpXG4gICAgbWFuaWZlc3QgPSBqdXN0VXBncmFkZVZlcnNpb24obWFuaWZlc3QsICcxLjIxLjAnKTtcbiAgfVxuXG4gIHJldHVybiBtYW5pZmVzdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VTZW12ZXIodmVyc2lvbjogc3RyaW5nKSB7XG4gIGNvbnN0IHZlciA9IHNlbXZlci5jb2VyY2UodmVyc2lvbik7XG4gIGlmICghdmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgXCIke3ZlcnNpb259XCIgYXMgc2VtdmVyYCk7XG4gIH1cblxuICByZXR1cm4gdmVyO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGNvcHkgb2YgdGhlIG1hbmlmZXN0IHdpdGgganVzdCB0aGUgdmVyc2lvbiBmaWVsZCB1cGRhdGVkXG4gKlxuICogVXNlZnVsIGlmIHRoZXJlIGFyZSBwcm90b2NvbCBjaGFuZ2VzIHRoYXQgYXJlIGF1dG9tYXRpY2FsbHkgYmFja3dhcmRzXG4gKiBjb21wYXRpYmxlLlxuICovXG5mdW5jdGlvbiBqdXN0VXBncmFkZVZlcnNpb24obWFuaWZlc3Q6IEFzc2VtYmx5TWFuaWZlc3QsIHZlcnNpb246IHN0cmluZyk6IEFzc2VtYmx5TWFuaWZlc3Qge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbWFuaWZlc3QsIHsgdmVyc2lvbiB9KTtcbn1cbiJdfQ==